# 数字存储 2.0 Mod 代码解析

## 一、核心架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Building_StorageCore                      │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  virtualStorage: List<StoredItemData>               │    │
│  │  (虚拟存储 - 只保存数据，不保存真实Thing)            │    │
│  └─────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  SlotGroup (预留物品 - 真实Thing，用于原版兼容)      │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
         │                    │                    │
    ┌────┴────┐          ┌────┴────┐          ┌────┴────┐
    │Interface│          │OutputIF │          │DiskCab  │
    │(输入)   │          │(输出)   │          │(扩容)   │
    └─────────┘          └─────────┘          └─────────┘
```

## 二、原版关键类

### 2.1 Building_Storage (原版存储建筑基类)

**文件**: `Assembly-CSharp/RimWorld/Building_Storage.cs`

```csharp
[StaticConstructorOnStartup]
public class Building_Storage : Building, ISlotGroupParent, IStoreSettingsParent, IHaulDestination, IStorageGroupMember, IHaulEnroute, ILoadReferenceable
{
    public StorageSettings settings;
    public StorageGroup storageGroup;
    public SlotGroup slotGroup;
    
    public Building_Storage()
    {
        this.slotGroup = new SlotGroup(this);
    }
    
    // 检查是否接受物品
    public bool Accepts(Thing t)
    {
        return this.GetStoreSettings().AllowedToAccept(t);
    }
    
    // 获取所有存储格子
    public virtual IEnumerable<IntVec3> AllSlotCells()
    {
        foreach (IntVec3 intVec in GenAdj.CellsOccupiedBy(this))
        {
            yield return intVec;
        }
    }
}
```

**关键点**:
- `SlotGroup` 管理存储格子和其中的物品
- `StorageSettings` 控制存储过滤器
- `Accepts()` 是原版检查物品是否可存储的入口

### 2.2 WorkGiver_DoBill.TryFindBestBillIngredients (原版材料查找)

**文件**: `Assembly-CSharp/RimWorld/WorkGiver_DoBill.cs`

```csharp
private static bool TryFindBestBillIngredients(Bill bill, Pawn pawn, Thing billGiver, 
    List<ThingCount> chosen, List<IngredientCount> missingIngredients)
{
    return WorkGiver_DoBill.TryFindBestIngredientsHelper(
        (Thing t) => WorkGiver_DoBill.IsUsableIngredient(t, bill), 
        (List<Thing> foundThings) => WorkGiver_DoBill.TryFindBestBillIngredientsInSet(
            foundThings, bill, chosen, 
            WorkGiver_DoBill.GetBillGiverRootCell(billGiver, pawn), 
            billGiver is Pawn, missingIngredients), 
        bill.recipe.ingredients, pawn, billGiver, chosen, bill.ingredientSearchRadius);
}
```

**TryFindBestIngredientsHelper 核心逻辑**:
1. 从工作台位置开始区域遍历
2. 检查 `IHaulSource` (如深层存储)
3. 遍历区域内的 `HaulableEver` 物品
4. 验证: `Spawned`, `!IsForbidden`, `CanReserve`
5. 调用 `foundAllIngredientsAndChoose` 检查是否找齐

### 2.3 ResourceCounter (原版资源计数)

**文件**: `Assembly-CSharp/RimWorld/ResourceCounter.cs`

```csharp
public sealed class ResourceCounter
{
    private readonly Dictionary<ThingDef, int> countedAmounts = new Dictionary<ThingDef, int>();
    
    public int GetCount(ThingDef rDef)
    {
        if (rDef.resourceReadoutPriority == ResourceCountPriority.Uncounted)
            return 0;
        if (this.countedAmounts.TryGetValue(rDef, out int num))
            return num;
        return 0;
    }
    
    public void UpdateResourceCounts()
    {
        this.ResetResourceCounts();
        List<SlotGroup> allGroupsListForReading = this.map.haulDestinationManager.AllGroupsListForReading;
        for (int i = 0; i < allGroupsListForReading.Count; i++)
        {
            foreach (Thing thing in allGroupsListForReading[i].HeldThings)
            {
                // 统计 SlotGroup 中的物品
                if (innerIfMinified.def.CountAsResource)
                {
                    this.countedAmounts[def] += innerIfMinified.stackCount;
                }
            }
        }
    }
}
```

### 2.4 ThingMaker (原版物品创建)

**文件**: `Assembly-CSharp/Verse/ThingMaker.cs`

```csharp
public static class ThingMaker
{
    public static Thing MakeThing(ThingDef def, ThingDef stuff = null)
    {
        // 验证 stuff 合法性
        if (def.MadeFromStuff && stuff == null)
        {
            stuff = GenStuff.DefaultStuffFor(def);
        }
        
        // 通过反射创建实例
        Thing thing = (Thing)Activator.CreateInstance(def.thingClass);
        thing.def = def;
        thing.SetStuffDirect(stuff);
        thing.PostMake();
        thing.PostPostMake();
        return thing;
    }
}
```

### 2.5 StoreUtility.TryFindBestBetterStorageFor (原版存储查找)

**文件**: `Assembly-CSharp/RimWorld/StoreUtility.cs`

```csharp
public static bool TryFindBestBetterStorageFor(Thing t, Pawn carrier, Map map, 
    StoragePriority currentPriority, Faction faction, 
    out IntVec3 foundCell, out IHaulDestination haulDestination, bool needAccurateResult = true)
{
    // 1. 先找 SlotGroup 存储
    if (StoreUtility.TryFindBestBetterStoreCellFor(t, carrier, map, currentPriority, faction, out invalid, needAccurateResult))
    {
        storagePriority = invalid.GetSlotGroup(map).Settings.Priority;
    }
    
    // 2. 再找非 SlotGroup 存储 (如深层存储)
    if (!StoreUtility.TryFindBestBetterNonSlotGroupStorageFor(t, carrier, map, currentPriority, faction, out haulDestination2, false, true))
    {
        haulDestination2 = null;
    }
    
    // 3. 比较优先级，返回最佳存储位置
    if (haulDestination2 != null && haulDestination2.GetStoreSettings().Priority > storagePriority)
    {
        haulDestination = haulDestination2;
        return true;
    }
    foundCell = invalid;
    haulDestination = invalid.GetSlotGroup(map).parent;
    return true;
}
```

## 三、Mod 核心实现

### 3.1 StoredItemData (虚拟物品数据)

**文件**: `Source/Data/StoredItemData.cs`

```csharp
public class StoredItemData : IExposable
{
    public ThingDef def;           // 物品定义
    public ThingDef stuffDef;      // 材质
    public QualityCategory quality; // 品质
    public int hitPoints;          // 耐久
    public int stackCount;         // 数量
    public string uniqueId;        // 唯一ID

    public StoredItemData(Thing thing)
    {
        this.def = thing.def;
        this.stuffDef = thing.Stuff;
        this.stackCount = thing.stackCount;
        this.hitPoints = thing.HitPoints;
        this.uniqueId = Guid.NewGuid().ToString();
        
        // 提取品质
        CompQuality compQuality = thing.TryGetComp<CompQuality>();
        if (compQuality != null)
        {
            this.quality = compQuality.Quality;
        }
    }

    // 根据数据生成真实 Thing
    public Thing CreateThing()
    {
        Thing thing = ThingMaker.MakeThing(this.def, this.stuffDef);
        thing.stackCount = this.stackCount;
        if (this.hitPoints > 0)
        {
            thing.HitPoints = this.hitPoints;
        }
        CompQuality compQuality = thing.TryGetComp<CompQuality>();
        if (compQuality != null)
        {
            compQuality.SetQuality(this.quality, ArtGenerationContext.Colony);
        }
        return thing;
    }

    public bool Matches(ThingDef thingDef, ThingDef stuff = null)
    {
        return this.def == thingDef && this.stuffDef == stuff;
    }
}
```

**核心思想**: 用轻量级数据对象代替重量级 Thing 对象，只在需要时才实体化。

### 3.2 Building_StorageCore (存储核心)

**文件**: `Source/Components/Building_StorageCore.cs`

**关键字段**:
```csharp
public class Building_StorageCore : Building_Storage, IRenameable
{
    // 虚拟存储：不保存真实 Thing，只保存数据
    private List<StoredItemData> virtualStorage = new List<StoredItemData>();
    private Dictionary<string, StoredItemData> itemLookup = new Dictionary<string, StoredItemData>();

    // 预留物品系统：记录每种物品的预留数量（真实物品）
    private Dictionary<string, int> reservedItemCounts = new Dictionary<string, int>();
    
    // 网络组件
    private List<Building_Interface> interfaces = new List<Building_Interface>();
    private List<Building_OutputInterface> outputInterfaces = new List<Building_OutputInterface>();
    private List<Building_DiskCabinet> diskCabinets = new List<Building_DiskCabinet>();
}
```

**核心方法**:

```csharp
// 重写 Accepts - 检查是否接受物品
public new bool Accepts(Thing t)
{
    if (!base.Accepts(t)) return false;
    if (!this.Powered) return false;

    // 检查是否能合并到已有组
    foreach (StoredItemData existing in this.virtualStorage)
    {
        if (existing.Matches(t.def, t.Stuff) && 
            existing.quality == (t.TryGetComp<CompQuality>()?.Quality ?? QualityCategory.Normal))
        {
            return true;  // 可以合并，不占用新组
        }
    }
    
    // 不能合并，需要新组，检查容量
    return this.GetUsedCapacity() < this.GetCapacity();
}

// 存储物品到虚拟存储
public void StoreItem(Thing thing)
{
    StoredItemData data = new StoredItemData(thing);
    StoreItemData(data);
}

// 从虚拟存储提取物品
public Thing ExtractItem(ThingDef def, int count, ThingDef stuff = null)
{
    foreach (StoredItemData item in this.virtualStorage)
    {
        if (item.Matches(def, stuff) && item.stackCount >= count)
        {
            item.stackCount -= count;
            if (item.stackCount <= 0)
            {
                this.virtualStorage.Remove(item);
            }
            
            StoredItemData extractData = new StoredItemData
            {
                def = item.def,
                stuffDef = item.stuffDef,
                quality = item.quality,
                hitPoints = item.hitPoints,
                stackCount = count
            };
            return extractData.CreateThing();
        }
    }
    return null;
}
```

**Tick 逻辑** (自动转换):
```csharp
protected override void Tick()
{
    base.Tick();
    if (!this.Powered) return;

    // 每 60 tick 维护预留物品
    if (Find.TickManager.TicksGame % 60 == 0)
    {
        MaintainReservedItems();
    }
    
    // 每 300 tick 检查转换
    if (Find.TickManager.TicksGame % 300 == 0)
    {
        // 检查是否有物品超过预留数量
        // 超出部分调用 AsyncItemConverter.StartAsyncConversion
    }
}
```

### 3.3 Building_Interface (输入接口)

**文件**: `Source/Components/Building_Interface.cs`

```csharp
public class Building_Interface : Building_Storage
{
    private Building_StorageCore boundCore;
    
    // 接收物品时，传送到核心
    public override void Notify_ReceivedThing(Thing newItem)
    {
        base.Notify_ReceivedThing(newItem);
        
        if (!this.IsActive || this.boundCore == null) return;
        
        if (this.boundCore.CanReceiveThing(newItem))
        {
            if (newItem.Spawned)
            {
                newItem.DeSpawn(DestroyMode.Vanish);
            }
            Map targetMap = this.boundCore.Map ?? base.Map;
            GenPlace.TryPlaceThing(newItem, this.boundCore.Position, targetMap, ThingPlaceMode.Near);
            FleckMaker.ThrowLightningGlow(this.boundCore.DrawPos, targetMap, 0.5f);
        }
    }
    
    // 重写 Accepts - 委托给核心
    public new bool Accepts(Thing t)
    {
        if (!this.IsActive) return false;
        if (this.boundCore == null || !this.boundCore.CanReceiveThing(t)) return false;
        return base.Accepts(t);
    }
}
```

## 四、Harmony Patches

### 4.1 Patch_ResourceCounter_GetCount (资源计数)

**文件**: `Source/HarmonyPatches/Patch_ResourceCounter.cs`

```csharp
[HarmonyPatch(typeof(ResourceCounter), "GetCount")]
public static class Patch_ResourceCounter_GetCount
{
    public static void Postfix(ref int __result, ThingDef rDef, ResourceCounter __instance)
    {
        if (rDef.resourceReadoutPriority == ResourceCountPriority.Uncounted) return;

        DigitalStorageGameComponent gameComp = Current.Game?.GetComponent<DigitalStorageGameComponent>();
        if (gameComp == null) return;

        // 统计所有核心中的该资源数量
        int totalInCores = 0;
        foreach (Building_StorageCore core in gameComp.GetAllCores())
        {
            if (core == null || !core.Spawned || !core.Powered) continue;
            totalInCores += core.GetItemCount(rDef, null);
        }

        // 将核心中的数量加到原版结果中
        if (totalInCores > 0)
        {
            __result += totalInCores;
        }
    }
}
```

**作用**: 让左上角资源面板显示虚拟存储中的物品数量。

### 4.2 Patch_WorkGiver_DoBill_TryFindBestBillIngredients (工作台材料)

**文件**: `Source/HarmonyPatches/Patch_WorkGiver_DoBill_TryFindBestBillIngredients.cs`

```csharp
[HarmonyPatch(typeof(WorkGiver_DoBill), "TryFindBestBillIngredients")]
public static class Patch_WorkGiver_DoBill_TryFindBestBillIngredients
{
    public static void Postfix(ref bool __result, Bill bill, Pawn pawn, Thing billGiver, ref List<ThingCount> chosen)
    {
        // 如果已经找到材料，不需要处理
        if (__result) return;

        // 检查是否有访问权限（有芯片或有接口）
        bool hasChip = PawnStorageAccess.HasTerminalImplant(pawn);
        bool hasInterface = HasAccessibleInterface(pawn.Map, gameComp);
        if (!hasChip && !hasInterface) return;

        // 遍历配方材料
        foreach (IngredientCount ingredient in billProd.recipe.ingredients)
        {
            // 1. 先检查预留物品
            // 2. 不够则从虚拟存储补货
            // 3. 传送到工作台位置（如果有芯片）
            // 4. 添加到 chosen 列表
        }

        if (virtualIngredients.Count == billProd.recipe.ingredients.Count)
        {
            chosen.AddRange(virtualIngredients);
            __result = true;  // 告诉原版找到了材料
        }
    }
}
```

**工作流程**:
1. 原版 `TryFindBestBillIngredients` 返回 false（找不到材料）
2. Postfix 检查虚拟存储
3. 从虚拟存储提取并 Spawn 到地图
4. 如果有芯片，传送到工作台位置
5. 注入到 `chosen` 列表，返回 true

### 4.3 Patch_Pawn_JobTracker_StartJob_Teleport (Job 传送)

**文件**: `Source/HarmonyPatches/Patch_Pawn_JobTracker_StartJob_Teleport.cs`

```csharp
[HarmonyPatch(typeof(Pawn_JobTracker), "StartJob")]
public static class Patch_Pawn_JobTracker_StartJob_Teleport
{
    public static bool Prefix(Job newJob, Pawn ___pawn)
    {
        // 处理 DoBill（工作台制作）
        if (newJob.def == JobDefOf.DoBill)
        {
            HandleDoBill(newJob, ___pawn);
        }
        // 处理 HaulToContainer（蓝图建造）
        else if (newJob.def == JobDefOf.HaulToContainer)
        {
            HandleHaulToContainer(newJob, ___pawn);
        }
        // 处理其他 Job 类型...
        
        return true;  // 继续原版逻辑
    }
    
    private static void HandleDoBill(Job job, Pawn pawn)
    {
        // 检测材料是否在核心的 SlotGroup 中
        Building_StorageCore materialCore = FindCoreWithItem(material, pawn.Map);
        if (materialCore != null)
        {
            // 传送到合适位置
            IntVec3 spawnPos = GetSpawnPosition(pawn, materialCore, pawn.Map);
            material.DeSpawn(0);
            GenSpawn.Spawn(material, spawnPos, pawn.Map, WipeMode.Vanish);
            FleckMaker.ThrowLightningGlow(material.DrawPos, material.Map, 0.5f);
            
            // 替换 Job 目标
            job.targetQueueB[i] = material;
        }
    }
}
```

**作用**: 在 Job 启动时，检测材料位置，如果在核心中则传送到 Pawn 附近。

## 五、工作流程图

### 5.1 物品存入流程

```
物品放入接口 → Interface.Notify_ReceivedThing()
                    ↓
              DeSpawn + GenPlace 到核心位置
                    ↓
              核心 Tick() 检测到新物品
                    ↓
              超过预留数量? → 是 → AsyncItemConverter.StartAsyncConversion()
                    ↓                        ↓
                   否                  StoreItem() → StoredItemData
                    ↓                        ↓
              保留为预留物品              DeSpawn 原物品
```

### 5.2 工作台制作流程

```
WorkGiver_DoBill.TryFindBestBillIngredients()
                    ↓
              原版找不到材料 (__result = false)
                    ↓
              Postfix: 检查虚拟存储
                    ↓
              找到匹配材料? → 否 → 返回 false
                    ↓
                   是
                    ↓
              ExtractItem() 从虚拟存储提取
                    ↓
              GenSpawn.Spawn() 到核心位置
                    ↓
              有芯片? → 是 → 传送到工作台位置
                    ↓
              添加到 chosen 列表
                    ↓
              __result = true
                    ↓
              Pawn_JobTracker.StartJob() Prefix
                    ↓
              检测材料在核心中 → 传送到 Pawn 位置
                    ↓
              原版 Job 正常执行
```

## 六、性能优化

1. **异步转换** (`AsyncItemConverter`)
   - 分帧处理大量物品转换
   - 减少单帧 GC 压力

2. **对象池** (`ObjectPool`)
   - 复用 Dictionary 和 List
   - 避免频繁内存分配

3. **延迟检查**
   - 60 tick 维护预留物品
   - 300 tick 检查转换
   - 减少计算频率

4. **预留物品系统**
   - 保留少量真实物品
   - 避免频繁的虚拟化/实体化转换
   - 保证原版 AI 兼容性

## 七、关键设计决策

| 问题 | 解决方案 |
|------|----------|
| 原版 AI 找不到虚拟物品 | 预留物品系统 + Harmony Patch |
| 资源面板不显示虚拟物品 | Patch_ResourceCounter |
| 工作台找不到材料 | Patch_WorkGiver_DoBill |
| 物品传送 | Job StartJob Prefix + FleckMaker 特效 |
| 存档兼容 | StoredItemData 实现 IExposable |
| 跨地图支持 | DigitalStorageGameComponent 全局管理 |
